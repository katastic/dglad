programming notes
------------
	- if two values (like x and y) are LINKED and represent something like a POSITION. then MAKE THEM A OBJECT. and NAME IT.
		al_draw_bitmap(bitmap, x=500, y=300, 0); // no.
		drawBitmap(bitmap, pair(x,y), 0); // yes. NOW we know that this is some kind of position or a velocity.
		
		now watch as we scale up:
		
		al_draw_rectangle(bitmap, 32, 63, 20, 250, 230);
		drawRectangle(bitmap, pair(32, 64), pair(20, 250), 20);  
		
		see how much easier that is broken up? You specifying THINGS, in this case positions, and not just numbers.
		
		it may not be "upper left, lower right" but it's super obvious we have two points now. And, in the function signature now we can name those variables pair upperLeft, pair upperRight instead of x1, y1, x2, y2.
		
	- name EVERYTHING
		- variables. structures. and nested functions. THE CODE IS DOCUMENTATION. Instead of a block of code with a COMMENT above it describing what it does, replace that with a function that DESCRIBES what the code is doing.
	- if you're using a language that doesn't have those features. Use a language that does. Or enjoy clunking rocks together to make a fire.
	- The API SHOULD IMPLY both whats going on, and how to use it.
	- You shouldn't BE ABLE TO use an API wrong.
		- Allegro 5. instead of letting people call functions without first setting up an allegro_init():
			- make allegro init return a CONTEXT and the ONLY way to even CALL allegro functions (that need allegro live first), is to use that CONTEXT to interact with them. And if the context is null? Congrats, it's obvious it failed to initialize.
		- Don't over-generalize. Your code is going to be used. Make it work for that use and work to generalize it later. Don't start with some metaphorical abstract use case that works for literally everything but basically contributes to nothing because it has to cover 5000 edge cases. 

	- don't assume the PERFORMANCE of what you CAN SEE, matters compared to what you CANNOT SEE.
		- just because sending a bunch of structs means you'll be using pair[0] == x, pair[1] == y instead of just x,y in functions
		(a single level of indirection) means NOTHING compared to the indirection you don't see: virtual functions, for 
		example, but ORDERS OF A MAGNITUDE worse are a single call to a math function like SQRT and orders of a magnitude 
		worse than that, DRAWING A BITMAP.
		
		If you can call 4 if statements, comparing floats to see if a bitmap is even on the screen before drawing it? For every bitmap?
		that's "overhead" right? Wrong. Compared to the amount of logic that goes into drawing an Allegro bitmap, checking pixel formats, 
		checking parent bitmaps, and actually drawing it? Nothing you do even comes close unless you're doing something terribly wrong like
		using an O^3 formula.

	- don't repeat yourself. Even in a function, use a nested function which now gives a NAME to that block of code you kept repeating.
	- Even if you're using a more archiac language like C or C++, GCC (and LLVM) often times have extensions that add things like nested functions into the langauge outside of the spec.


















oriam notes
------------

	- metadata for texture atlas and isPassable

	- pgymentizePrinter works but it writes to STDOUT itself. It also doesn't typesafe the input. Also formatting is broken and you have to manually use format() since its just using strings.
		--> It might be possible to use a "persistentPrettyPrinter" (PPP?) with the pygments method because you can start a process
		here and leave it running and pipe your input to it. (Though the harder part might be constantly getting data back without it closing.)  
		
			https://dlang.org/library/std/process/pipe_process.html
			
		- there are alternative syntax highlighters that are supposedly faster. CodeRay is ruby. there's rust ones. etc.
			https://github.com/rubychan/shootout
			benchmark
			
			
	- create water splashes upon entering water tile
			
			

	- If I'm doing IMPLIED viewport drawing, why am I passing viewport v's to everything?


	- DEBUGGING with tagging. A debug channel (that can be piped to stdout + color) but it only applies to objects with the tag isDebugging (and we could use assert)
	
	
	
	+ generators
	- multiple resources or just $$$




	- what kind of "traps" protections do we have, because basically this is a horizontal tower defense game.
	
		- non-damaging types that do things like: 
			- decrease speed (sludge)
				- increase speed? (why? maybe for timing something)
			- bait?
			- burning traps? (that does damage, but also burning can be a debuff)
			- wet traps (+wet)
			- electrical traps (/w wet)
			- oil traps? (+flammable, +sticky)
			- ice traps? (+slow)
			
		contrast status effect turrets with primary turrets:

			- arrow (anti-infantry, arc, anything straight line?)
			- cannon (low arc)
			- catapult/trebuchet (high arc)
			- lightning tower? now it's just a normal tower defense game...


	- we could have (certain) enemies DESTROY FORTIFICATIONS
		- wood, stone, improved stone/metal gate/portcullis
		
		we could make the world HARDCODED and have traps let you extend out from that and block certian paths.
		 the problem is we've gone far away from "Oriam".
		 
		Oriam could be more like "mario maker" where you can build any kind of world layout (with costs the more you change it from the starting setup, whether adding or subtracting). But if we have some sort of "value" function based on "my map layout"
		that equates difficulty of monsters to get to home (A* path difficulty), then how we basically know the monsters will always
		win or fail based on that value function.



D notes
--------------------------------------------------------------------------------
 - scope(exit) statement; seems like an incredibly dumb and dangerous construct that 
 ruins your normal flow of code worse than goto. You could easily have nested if statements that
 "add" things onto the end of the code block and who knows which one gets called in which order!
	their own example might have an error:
		https://dlang.org/library/std/process/pipe_process.html	

	there's TWO scope(exits)! But the first one needs(?) to get used up by time the second one is, but
	the scopes should be at the end of the code block? Which might be doing a scope exit on the second 
	variable reference, twice, instead of one on each.

 - the first assignment of a variable in a constructor ... is actually an initializer. So the .init value is set. Any further uses will however be an [assignment] which could(?) have different effectss if you're say, initing then setting another class object inside your constructor.


--------------------------------------------------------------------------------

pygmentize -L

Styles:
~~~~~~~
* default:
    The default style (inspired by Emacs 22).
* emacs:
    The default style (inspired by Emacs 22).
* friendly:
    A modern style based on the VIM pyte theme.
* colorful:
    A colorful style, inspired by CodeRay.
* autumn:
    A colorful style, inspired by the terminal highlighting style.
* murphy:
    Murphy's style from CodeRay.
* manni:
    A colorful style, inspired by the terminal highlighting style.
* monokai:
    This style mimics the Monokai color scheme.
* perldoc:
    Style similar to the style used in the perldoc code blocks.
* pastie:
    Style similar to the pastie default style.
* borland:
    Style similar to the style used in the borland IDEs.
* trac:
    Port of the default trac highlighter design.
* native:
    Pygments version of the "native" vim theme.
* fruity:
    Pygments version of the "native" vim theme.
* bw:
    
* vim:
    Styles somewhat like vim 7.0
* vs:
    
* tango:
    The Crunchy default Style inspired from the color palette from the Tango Icon Theme Guidelines.
* rrt:
    Minimalistic "rrt" theme, based on Zap and Emacs defaults.
* xcode:
    Style similar to the Xcode default colouring theme.
* igor:
    Pygments version of the official colors for Igor Pro procedures.
* paraiso-light:
    
* paraiso-dark:
    
* lovelace:
    The style used in Lovelace interactive learning environment. Tries to avoid the "angry fruit salad" effect with desaturated and dim colours.
* algol:
    
* algol_nu:
    
* arduino:
    The ArduinoÂ® language style. This style is designed to highlight the Arduino source code, so exepect the best results with it.
* rainbow_dash:
    A bright and colorful syntax highlighting theme.
* abap:
    
* solarized-dark:
    The solarized style, dark.
* solarized-light:
    The solarized style, light.
* sas:
    Style inspired by SAS' enhanced program editor. Note This is not meant to be a complete style. It's merely meant to mimic SAS' program editor syntax highlighting.
* stata:
    Light mode style inspired by Stata's do-file editor. This is not meant to be a complete style, just for use with Stata.
* stata-light:
    Light mode style inspired by Stata's do-file editor. This is not meant to be a complete style, just for use with Stata.
* stata-dark:
    
* inkpot:
    
